今天和明天的任务 
参考群里的视频学习jdk8 hashmap源码
并完成相关练习题

1 阅读jdk7的hashmap源码（更简单），思考为啥jdk7在扩容的时候（多线程环境下） 会产生死循环？
在jdk1.7中 使用头插法将将数据插入到数组下标元素的上面，但是多线程咋执行put操作时，如果进行扩容，由于多个线程进行put会导致链表的打乱顺序.
A线程：3->7->null 扩容后  7->3->null              \ 
					结果: 3<===>7
B线程：3->7->null（7->3->null） 扩容：3->7  /

2 简单说说 jdk8的hashmap 添加一个元素的 操作流程？
hashMap添加一个元素
	i.计算（对key求hash值)，在计算数组的下标(n-1）& hash
	1.找到key所指向的数组下标，如果数组中没有元素，则直接加入
	2.else 如果数组下标中有元素，且key相同，但value不同则进行替换
	3.else:遍历循环当前下标下的所有数组，直到遇见p.next=null的情况下，以链表的形式插入数据
	4.当插入的那个链表的长度>8时，则把链表转化为RBT

3 HashMap的数据结构（jdk7和jdk8）？
jdk1.7：hashMap 以数组+链表的结构
   idk1.8:数组+链表+RBT

4 jdk8的hashmap 拉链法导致的链表过深，为什么不用二叉查找树（bst）代替而选择红黑树？为什么不一直使用红黑树（而是链表长度要超过8） ？
  bst可能会发生极端的情况，使的bst向左/右偏斜过度，而变成类似于链表的形式
 不一直使用红黑树的原有的原因：因为在定义RBT结点的时候，至少比链表多定义了一个结点，这样在还是挺浪费空间的，只有在结点足够多的时候才会进行转换。而且，根据泊松分布，达到8以上的不算
太多，故而也不会浪费太多的资源。 但是 RBT的时间复杂度为O（log(n)）而链表是o(n)级别，在考虑时间的情况下，只能牺牲一点空间来换取时间。


5 如果 HashMap 的大小超过了负载因子（load factor）定义的容量怎么办？
hashmap会进行扩容，把容量扩大为原来的两倍的数组，并把原来的数据转移到新的数组中去
	
6 jdk8的hashmap  扩容的时候 如何确定元素的新下标？
通过循环查看数组的下标的有元素的进行转移，没有元素的忽略。	
	1.有元素且元素只有一个，重新计算它的key，以及下标值=（(新长度-1）&hash），并把元素转移
	2.如果元素是链表，则  hash&oldCap 
			(1)=0 则和元素原来的下标一样
			（2）！=0 则下标变为原来下标+原来容量
	3.如果是RBT则把rbt分割，在计算下标并转移
